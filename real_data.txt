install.packages("C:/Study/project3/limma_3.30.4.zip",repos=NULL)
install.packages("locfit")
install.packages("C:/Study/project3/edgeR_3.16.3.zip",repos=NULL)
install.packages("C:/Study/project3/fitdistrplus_1.0-7.zip",repos=NULL)
install.packages("matrixStats")
library(matrixStats)
library(edgeR)
library(fitdistrplus)
q.value=function(p, lambda=seq(0,0.95,0.05)) {
#
#This is Storey and Tibshirani's (PNAS, 2003) default method
#for determining the q-values.
#
#Code was originally obtained from John Storey's Web site.
#It has been edited slightly.
#
  m<-length(p) 
  pi0 <- rep(0,length(lambda))
  for(i in 1:length(lambda)) {
    pi0[i] <- mean(p >= lambda[i])/(1-lambda[i])
  }
  spi0 <- smooth.spline(lambda,pi0,df=3)
  pi0 <- max(predict(spi0,x=1)$y,0)
  pi0 <- min(pi0,1)
  u <- order(p)
  v <- rank(p)
  qvalue <- pi0*m*p/v
  qvalue[u[m]] <- min(qvalue[u[m]],1)
  for(i in (m-1):1) {
    qvalue[u[i]] <- min(qvalue[u[i]],qvalue[u[i+1]],1)
  }
  return(qvalue)
}
a<-read.table('C:/Study/project3/update/data/B783_kidney.count.txt')
b<-read.table('C:/Study/project3/update/data/D892_kidney.count.txt')
c<-read.table('C:/Study/project3/update/data/B799_kidney.count.txt')
d<-read.table('C:/Study/project3/update/data/C009_kidney.count.txt')
e<-read.table('C:/Study/project3/update/data/J489A_kidney.count.txt')
f<-read.table('C:/Study/project3/update/data/J355_kidney.count.txt')
g<-read.table('C:/Study/project3/update/data/R868b_kidney.count.txt')
h<-read.table('C:/Study/project3/update/data/J835_kidney.count.txt')
counti<-cbind(a,b[,2],c[,2],d[,2],e[,2],f[,2],g[,2],h[,2])
counti<-counti[-c(59168:59172),]
x<-counti[,-1]
group<-factor(rep(1:2,each=4))
y<-DGEList(counts=x, group=group)
keep<-rowSums(cpm(y)>1)>=2
geneinfo<-a[-c(59168:59172),][keep,1]
y<-y[keep, ,keep.lib.sizes=FALSE]
y<-calcNormFactors(y)
obs<-cpm(y,normalized.lib.sizes=TRUE)
obs<-round(obs)


repli<-4
cc<-dim(obs)[1]
###################################Limma###########################################################################
group<-factor(rep(1:2,each=repli))
design<-model.matrix(~group)
v<-voomWithQualityWeights(y, design, normalization='none',lib.size=rep(1,2*repli))
vfit<-lmFit(v) 
vfit<-eBayes(vfit,trend=TRUE)
p1<-vfit$p.value[,2]
###################################edgeR###########################################################################
y<-estimateDisp(y,design)
fit<-glmFit(y,design)
lrt<-glmLRT(fit)
p2<-lrt$table$PValue
###################################NB LRT test######################################################################
p3<-c(NA)
for (i in 1:cc){
if (all(obs[i,]==0)) {fit1<-0
}else {fit1<-fitdist(obs[i,],"nbinom",method="mle",control=list(maxit=2000000))$loglik}
if (all(obs[i,1:repli]==0)) {fit2<-0
}else {fit2<-fitdist(obs[i,1:repli],"nbinom",method="mle",control=list(maxit=2000000))$loglik}
if (all(obs[i,(repli+1):(repli*2)]==0)) {fit3<-0
}else {fit3<-fitdist(obs[i,(repli+1):(repli*2)],"nbinom",method="mle",control=list(maxit=2000000))$loglik}
t<--2*(fit1-fit2-fit3)
p3[i]<-1-pchisq(t,df=2)
}
###################################LRT+edge R########################################################################
p4<-c(NA)
ttt<-matrix(c(NA),nrow=cc,ncol=(choose(repli*2,repli)/2))
for (j in 1:(choose(repli*2,repli)/2)){
grp<-rep(2,(repli*2))
grp[combn(repli*2,repli)[,j]]<-1
dm0<-DGEList(counts=obs,lib.size=rep(1,(repli*2)),norm.factors=rep(1,(repli*2)),group=grp)
ddm0<-estimateDisp(dm0)$tagwise.dispersion
dm1<-DGEList(counts=obs[,grp==1],lib.size=rep(1,repli),norm.factors=rep(1,repli))
ddm1<-estimateDisp(dm1)$tagwise.dispersion
dm2<-DGEList(counts=obs[,grp==2],lib.size=rep(1,repli),norm.factors=rep(1,repli))
ddm2<-estimateDisp(dm2)$tagwise.dispersion
for (i in 1:cc){
if (all(obs[i,]==0)) {fit1<-0
}else {fit1<-fitdist(obs[i,],"nbinom",method="mle",fix.arg=list(size=1/ddm0[i]),control=list(maxit=2000000))$loglik}
if (all(obs[i,grp==1]==0)) {fit2<-0
}else {fit2<-fitdist(obs[i,grp==1],"nbinom",method="mle",fix.arg=list(size=1/ddm1[i]),control=list(maxit=2000000))$loglik}
if (all(obs[i,grp==2]==0)) {fit3<-0
}else {fit3<-fitdist(obs[i,grp==2],"nbinom",method="mle",fix.arg=list(size=1/ddm2[i]),control=list(maxit=2000000))$loglik}
ttt[i,j]<--2*(fit1-fit2-fit3)
}
}
null<-ttt[p3>=0.1,]
for (i in 1:cc){
p4[i]<-sum(null>ttt[i,1])/dim(null)[1]/dim(null)[2]
}

###################################q values###########################################################################
q1<-q.value(p1)
q2<-q.value(p2)
q3<-q.value(p3)
q4<-q.value(p4)


nobs<-obs[q4<0.05,]
mmat<-matrix(c(NA),nrow=dim(nobs)[1],ncol=1000)
for (j in 1:1000){
samp<-sample(1:4,4,replace=T)
mmat[,j]<-rowMeans(nobs[,samp])
}
mve<-rowMeans(mmat)
sdve<-sqrt(rowVars(mmat))
brl<-mve-2.5*sdve
bru<-mve+2.5*sdve
indi<-matrix(c(NA),nrow=dim(nobs)[1],ncol=4)
for (i in 1:dim(nobs)[1]){
for (j in 1:4){
indi[i,j]<-((nobs[i,j+4]>bru[i])|(nobs[i,j+4]<brl[i]))+0
}
}